<!DOCTYPE html>
<html>
<head>
<meta content="text/html" charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Методические рекомендации по ООП, II модуль</title>
<style lang="css">
body {
	--fg: #557;
	--bg: white;
	--fg-required: #38C;
	--fg-optional: #598;	
	--fg-template: #C39;
	--fg-link: #83C;
	--fg-hint: #C83;
	font-family: Sans-Serif;
	color: var(--fg);
	cursor: default;
	user-select: none;
}
select {
	color: var(--fg);
	font: bold 1em "Lucida Console";
}
.hidden {
	display: none; 
}
h1 {
	text-align: center;
}
h1, h3 {
	font-family: "Lucida Console";
}
h4 {
	font-family: "Lucida Console";
	margin: .2em;
}
.small {
	font-size: 60%;
}
.tiny {
	font-size: 50%;
	font-family: "Lucida Sans Unicode";
}
a {
	color: var(--fg-link);
}
em {
	font-style: normal;
	color: var(--fg-template);
	text-shadow: 0 0 2px var(--fg-template);
}
[hint]::before {
	font-weight: normal;
	font-style: normal;
	color: var(--fg-hint);
	content: '[' attr(hint) '] ';
}
#problems ol {
	list-style-type: upper-roman;
	color: darkgray;
	margin-bottom: 1em;
}
.required {
	--fg-task: var(--fg-required);
}
.optional {
	--fg-task: var(--fg-optional);
}
.task {
	font-family: "Lucida Console";
	border-bottom: 1px solid var(--fg-task);
	margin: 2px auto;
	max-width: 40em;
	list-style: none;
}
.task::before {
	color: var(--fg-task);
	text-shadow: 0 0 2px var(--fg-task);
	content: attr(value) "%";
	text-align: center;
	margin: .5em;
	width: 2em;
	float: right;
}
.task > *{
	margin-left: -2.5em;
}
.task > li {
	color: var(--fg-task);
	font-style: italic;
}
.spoiler {
	cursor: pointer;
}
.spoiler:hover {
	text-decoration: underline;
	--symbol: "\00D7";
}
.spoiler::before {
	color: var(--bg);
	background: var(--fg-task);
	content: var(--symbol, "?");
	text-align: center;
	font-style: normal;
	margin-right: .25em;
	padding: 0 .25em;
	float: left;
}
.closed:hover {
	text-decoration: underline;
	--symbol: "\2026";
}
.closed + * {
	display: none; 
}
</style>
</head>
<body onload="onLoad()">
<h1>
	<div class="small">Методические рекомендации к выполнению лабораторных работ по дисциплине</div> «Объектно-ориентированное программирование»
	<div class="small">2<sup>-го</sup> курса бакалавриата ИВТ</div>
	<div class="tiny">II модуль</div></h1>
<h2>Лабораторная работа №2<span class="nojs hidden">, вариант №<select id="selector" onchange="changeVar(event)"></select></span></h2>
<ol id="problems">
	<li v="1">Сотрудники офиса устали от растущих гор макулатуры и решили собраться на выходных в <em>T</em>. Поскольку вкусы у всех оказались разные, было решено поступить следующим образом: каждый из сотрудников подготовит список предпочтительных <em>T</em>, после чего из всех списков будут сформирован один общий список, содержащий только <em>T</em>, которые устраивают всех без исключения. Напишите программу, составляющий такой список из нескольких предложенных.
	<ol>
		<li>Коллекция: множество &lt;<em>T</em>&gt;</li>
		<li><em>T</em> = ресторан (строка)</li>
	</ol></li>
	<li v="2">Некоторые писатели, не добившиеся самостоятельной публикации, решили объединить усилия и выпустить сборник со своими работами. Оказалось, что все пишут в разных <em>T</em>, что может плохо сказаться на качестве сборника. Для повышения шансов на успешную публикацию, писатели решили найти все <em>T</em>, в которых у каждого из них есть опыт. Напишите для них программу, находящую в заданных списках все общие <em>T</em> и формирующую из них новый список.
	<ol>
		<li>Коллекция: множество &lt;<em>T</em>&gt;</li>
		<li><em>T</em> = жанр (строка)</li>
	</ol></li>
	<li v="3">Бакалавры математического факультета заметили, что вместо подготовки к приближающейся сессии они тратят слишком много времени в столовой. Чтобы сэкономить время, не оставшись при этом голодными, студенты решили заранее составить список всех <em>T</em>, которые достаточно питательны, всегда есть в достатке и которые можно съесть в пределах одной минуты. Требуется написать программу, позволяющую составить списки <em>T</em> по каждой из заданных категорий и определить <em>T</em>, принадлежащие одновременно всем трём категориям.
	<ol>
		<li>Коллекция: множество &lt;<em>T</em>&gt;</li>
		<li><em>T</em> = блюдо (строка)</li>
	</ol></li>
	<li v="4">Ресторан быстрого питания производит сокращение штата, заменяя обслуживающий персонал роботами. Чтобы определить кандидатов на повышение и увольнение, отдел кадров начал считать ошибки, совершённые каждым <em>K</em>. По окончании некоторого времени самых нерасторопных <em>K</em> уволят, а самых ответственных – повысят. Напишите программу, ведущую учёт ошибок каждого <em>K</em> и способную в любой момент определить кандидатов на увольнение и повышение.
	<ol>
		<li>Коллекция: хэш-таблица &lt;<em>K</em>, число ошибок&gt; с методом, возвращающим ключ <em>K</em> с минимумом ошибок и методом, возвращающим ключ <em>K</em> с максимумом ошибок.</li>
		<li><em>K =</em> сотрудник (строка)</li>
	</ol></li>
	<li v="5"><em>K</em> с кафедры робототехники собираются устроить соревнования с участием радиоуправляемых автомобилей. Призы, купленные на средства с последнего гранта, получат три <em>K</em>, победившие в большинстве соревнований. Напишите программу, ведущую учёт побед каждого <em>K</em> и способную составить список из трёх победителей.
	<ol>
		<li>Коллекция: хэш-таблица &lt;<em>K</em>, количество побед&gt; c методом, возвращающим три ключа <em>K</em> с максимальными значениями (победами)</li>
		<li><em>K =</em> студент (строка)</li>
	</ol></li>
	<li v="6">Филолог Филипп решил выучить иностранный язык и стать переводчиком. Грамматика ему даётся без особых проблем, но для обогащения словарного запаса нужно записывать новые <em>K</em>, и периодически повторять старые <em>K</em>. Напишите программу, позволяющую хранить количество повторений для каждого <em>K</em> и возвращающую количество всех выученных <em>K</em>, повторённых не меньше заданного числа раз.
	<ol>
		<li>Коллекция: хэш-таблица &lt;<em>K</em>, количество повторений&gt; с методом, принимающего число и возвращающим количество ключей <em>K</em>, значения (повторения) больше или равны этому числу</li>
		<li><em>K =</em> иностранное слово (строка)</li>
	</ol></li>
	<li v="7">Скучающие <em>K</em> с кафедры прикладной математики нашли себе необычное развлечение. Заметив однажды, что <em>V</em> уплетают свои обеды за считанные секунды, <em>K</em> устроили тотализатор и ежедневно пытаются угадать, кто быстрее справится со своей порцией. Напишите программу, позволяющую записывать ставки и выводить список <em>K</em>, сделавших ставку на заданного <em>V</em>.
	<ol>
		<li>Коллекция: хэш-таблица &lt;<em>K, V</em>&gt; с методом, принимающим некоторое значение <em>V</em>, и возвращающим список ключей <em>K</em> с тем же значением</li>
		<li><em>K =</em> профессор (строка); <em>V =</em> студент (строка)</li>
	</ol></li>
	<li v="8">Коммивояжёр собрал чемодан и приступил к выбору маршрута. Для этого нужно выяснить, кто из его постоянных клиентов заинтересован в приобретении хотя бы одной из взятых им <em>K</em> и готов предложить за неё <em>V</em>. Напишите программу, позволяющую составить список <em>K</em> и соответствующих им <em>V</em>, а также рассчитывающую потенциальную выручку от продажи всех <em>K</em>.
	<ol>
		<li>Коллекция: хэш-таблица &lt;<em>K, V</em>&gt; с методом расчёта суммы всех значений <em>V</em></li>
		<li><em>K =</em> вещь (строка); <em>V =</em> наибольшая цена (число)</li>
	</ol></li>
	<li v="9">Огромный скачок напряжения вывел из строя сервера института биоинформатики. После восстановления энергоснабжения оказалось, что была потеряна база данных с <em>K</em> и <em>V</em>. Напишите программу, которая может хранить соответствия <em>K</em> различным <em>V</em> и воссоздавать последовательность <em>V</em> по заданной последовательности <em>K</em>.
	<ol>
		<li>Коллекция: хэш-таблица &lt;<em>K, V</em>&gt; с методом, принимающим список ключей <em>K</em> и возвращающую соответствующий список значений <em>V</em></li>
		<li><em>K =</em> <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%BE%D0%BD">кодон</a> (строка); <em>V =</em> аминокислота (строка)</li>
	</ol></li>
	<li v="10">Блогер Боря хочет поблагодарить подписчиков за спонсирование своего путешествия. Для этого во время своей поездки он собирается сделать альбом из фотографий уникальных <em>V</em>. Чтобы ничего не пропустить, ему нужна программа, позволяющая записывать <em>K</em> и соответствующие им <em>V</em>, а также составляющая список <em>V</em> в порядке возрастания <em>K</em>.
	<ol>
		<li>Коллекция: бинарное дерево &lt;<em>K, V</em>&gt; с методом, возвращающим список значений <em>V</em> в порядке возрастания ключа <em>K</em></li>
		<li><em>K =</em> дата; <em>V =</em> астрономическое явление (строка)</li>
	</ol></li>
	<li v="11">До начала распродажи мебели и бытовой техники, магазину кухонных гарнитуров нужно срочно провести инвентаризацию. Для этого требуется программа, позволяющая записывать <em>K</em> и соответствующие <em>V</em>, а также составляющая список <em>V</em> в порядке возрастания <em>K</em>.
	<ol><li>Коллекция: бинарное дерево &lt;<em>K, V</em>&gt; с методом, возвращающим список значений <em>V</em> в порядке возрастания ключа <em>K</em></li>
	<li><em>K =</em> артикул (число); <em>V =</em> название кухонного гарнитура (строка)</li>
	</ol></li>
	<li v="12">Бакалавров с факультета математики, ухаживающих за бинарным деревом, не устраивает существующий журнал, поскольку они хотят знать заранее, кому в какой день приходить. Для этого им нужна программа, позволяющая вводить соответствия <em>K</em> и <em>V</em>, а также составляющая список <em>V</em> в порядке возрастания <em>K</em>.
	<ol>
		<li>Коллекция: бинарное дерево &lt;<em>K, V</em>&gt; с методом, возвращающим список значений <em>V</em> в порядке возрастания ключа <em>K</em></li>
		<li><em>K =</em> дата; <em>V =</em> студент (строка)</li>
	</ol></li>
	<li v="13">С появлением почтовой службы в квадратном королевстве, наконец, появилась возможность обмена сообщениями. Уйма различных почтовых индексов обескуражила почтальонов, поэтому они решили составить справочник, в котором каждому <em>K</em>, состоящему из нескольких цифр, соответствовал некоторый <em>V</em>. В помощь почтальонам, напишите программу, эффективно реализующую такой справочник, а также предлагающую функцию автодополнения <em>K</em> при неполном вводе.
	<ol>
		<li>Коллекция: префиксное дерево &lt;<em>K, V</em>&gt; с методом, возвращающим список хранящихся ключей <em>K</em>, начинающихся с заданной последовательности</li>
		<li><em>K =</em> последовательность цифр (строка); <em>V =</em> адрес почтового отделения (строка)</li>
	</ol></li>
	<li v="14">Студенты с кафедры электротехники обнаружили, что свет от новых ламп кафедры виден из их общежития, располагающегося в нескольких километрах. Они решили попробовать передавать закодированные сообщения, последовательно включая и выключая лампы, находящиеся на кафедре. Теперь студентам, следящим из общежития, нужна программа, позволяющая записывать <em>K</em> и соответствующие им <em>V</em>, а также предлагающая функцию автодополнения <em>K</em> при неполном вводе.
	<ol>
		<li>Коллекция: префиксное дерево &lt;<em>K, V</em>&gt; с методом, возвращающим список хранящихся ключей <em>K</em>, начинающихся с заданной последовательности</li>
		<li><em>K =</em> последовательность цветов (вектор/строка); <em>V =</em> буква (символ)</li>
	</ol></li>
	<li v="15">Юных бухгалтеров отправляют на курсы повышения квалификации для обучения языку программирования 1С. Для облегчения работы им нужен электронный справочник, позволяющий записывать <em>K</em> и соответствующие <em>V</em>, а также предлагающий функцию автодополнения <em>K</em> при неполном вводе.
	<ol>
		<li>Коллекция: префиксное дерево &lt;<em>K, V</em>&gt; с методом, возвращающим список хранящихся ключей <em>K</em>, начинающихся с заданной последовательности</li>
		<li><em>K =</em> слово, т.е. последовательность букв (строка); <em>V =</em> тип (перечисление: служебное слово/функция/константа)</li>
	</ol></li>
</ol>
<h3>I. Шаблонная коллекция</h3>
<ul class="required task" value="20">
	<h4 hint="Варианты">Структура класса</span></h4>
	<li class="spoiler">Класс является шаблонным и соответствует своему варианту</li>
	<ul>
		<li v="1 2 3" hint="1-3">коллекция реализована на основе <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">хэш-таблицы</a> по аналогии с <a href="http://www.cplusplus.com/reference/unordered_set/unordered_set/">std::unordered_set</a> или <a href="https://doc.qt.io/qt-5/qset.html">QSet</a></li>
		<li v="4 5 6 7 8 9" hint="4-9">коллекция реализована на основе <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">хэш-таблицы</a> по аналогии с <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/">std::unordered_map</a> или <a href="https://doc.qt.io/qt-5/qhash.html">QHash</a></li>
		<li v="4 5 6" hint="4-6">тип значения <em>V</em> является не шаблонным, а целым неотрицательным</li>
		<li v="1 2 3 4 5 6 7 8 9" hint="1-9">для хэш-функции можно использовать как свой алгоритм, так и уже <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F#%D0%92%D0%B8%D0%B4%D1%8B_%C2%AB%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9%C2%BB">готовый</a>; в коллекции реализовано <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0#%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D0%B9">разрешение коллизий</a></li>
		<li v="10 11 12" hint="10-12">коллекция реализована на основе <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">бинарного дерева</a> по аналогии с <a href="http://www.cplusplus.com/reference/map/map/">std::map</a> или <a href="https://doc.qt.io/qt-5/qmap.html">QMap</a></li>
		<li v="10 11 12" hint="10-12">считать, что для типа <em>K</em> реализован оператор &gt;</li>
		<li v="13 14 15" hint="13-15">коллекция реализована на основе <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">префиксного дерева</a> с использованием любого ассоциативного массива</a></li>
		<li v="13 14 15" hint="13-15">считать, что для типа <em>K</em> реализован оператор [];</li>
	</ul>
	<li class="spoiler">Класс содержит перечисленные пункты</li>
	<ul>
		<li>конструктор по умолчанию и конструктор копирования</li>
		<li>деструктор</li>
		<li>метод, удаляющий все хранящиеся значения из коллекции</li>
		<li>метод, возвращающий количество хранящихся в коллекции значений</li>
		<li>метод, принимающий путь к файлу и сохраняющий в него содержимое коллекции</li>
		<li>метод, принимающий путь к файлу и загружающий из него содержимое коллекции</li>
		<li v="1 2 3" hint="1-3">оператор ==, принимающий другую коллекцию и возвращающий истину, если обе коллекции хранят одинаковые значения <em>T</em> и ложь в противном случае</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">оператор ==, принимающий другую коллекцию и возвращающий истину, если обе коллекции хранят одинаковые пары ключ-значение <em>K, V</em> и ложь в противном случае</li>
		<li v="1 2 3" hint="1-3">оператор &lt;&lt;, добавляющий в коллекцию заданное значение <em>T</em></li>
		<li v="4 5 6" hint="4-6">оператор &lt;&lt;, добавляющий в коллекцию заданный ключ <em>K</em>. Если ключа не было в коллекции, его значение <em>V</em> будет равно 1. Если ключ уже был в коллекции, значение увеличится на единицу.</li>
		<li v="7 8 9 10 11 12 13 14 15" hint="7-15">метод, добавляющий в коллекцию заданную пару ключ-значение <em>K, V</em></li>
		<li v="1 2 3" hint="1-3">метод, удаляющий из коллекции заданное значение <em>T</em> при его наличии</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">метод, удаляющий из коллекции пару ключ-значение по произвольному ключу <em>K</em></li>
		<li v="1 2 3" hint="1-3">оператор [], принимающий значение <em>T</em> и возвращающий при наличии значения в коллекции истину, а при отсутствии – ложь</li>
		<li v="4 5 6" hint="4-6">оператор [], принимающий ключ <em>K</em> и возвращающий его значение <em>V</em></li>
		<li v="7 8 9 10 11 12 13 14 15" hint="7-15">оператор [], принимающий ключ <em>K</em> и возвращающий его значение <em>V</em> <strong>по&nbsp;ссылке</strong></li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">метод, принимающий ключ <em>K</em> и возвращающий при его наличии в коллекции истину, а при отсутствии – ложь</li>
		<li v="1 2 3" hint="1-3">оператор &amp;&amp;, принимающий другую коллекцию и возвращающий все общие значения <em>T</em> в виде новой коллекции</li>
		<li v="4" hint="4">метод, возвращающий ключ <em>K</em> с минимумом ошибок</li>
		<li v="4" hint="4">метод, возвращающий ключ <em>K</em> с максимумом ошибок</li>
		<li v="5" hint="5">метод, возвращающий список из трёх ключей <em>K</em> с максимальными значениями</li>
		<li v="6" hint="6">метод, принимающего число и возвращающим количество ключей <em>K</em>, значения которых больше или равны этому числу</li>
		<li v="7" hint="7">метод, принимающий значение <em>V</em>, и возвращающий список ключей <em>K</em> с этим значением</li>
		<li v="8" hint="8">метод, возвращающий сумму всех значений <em>V</em></li>
		<li v="9" hint="9">метод, принимающий список ключей <em>K</em> и возвращающий список соответствующих значений <em>V</em></li>
		<li v="10 11 12" hint="10-12">метод, возвращающий список всех значений <em>V</em> в порядке возрастания ключа <em>K</em></li>
		<li v="13 14 15" hint="13-15">метод, возвращающий список хранящихся ключей <em>K</em>, начинающихся с заданной последовательности</li>
	</ul>
	<li class="spoiler">Класс устойчив к ошибкам</li>
	<ul>
		<li>в деструкторе коллекции освобождается вся выделенная ей память</li>
		<li>публичные методы коллекции не принимают и не возвращают указатели на свои поля</li>
		<li v="4 5 6 7 8 9 10 11 12" hint="4-12">При обращении к несуществующим ключам предусмотрено исключение</li>
	</ul>
</ul>
<ul class="required task" value="30">
	<h4>Тестирование</h4>
	<li class="spoiler">Тесты отвечают следующим требованиям</li>
	<ul>
		<li>все тесты находятся в функции main()</li>
		<li>для тестирования используется функция assert() из библиотеки assert.h</li>
		<li>при отсутствии ошибок выводится сообщение об успешном прохождении тестов</li>
		<li>больше на экран ничего не выводится</li>
	</ul>
	<li class="spoiler">Присутствуют перечисленные проверки</li>
	<ol>
		<li>Размер коллекции, созданной конструктором по умолчанию, равен нулю</li>
		<li v="1 2 3" hint="1-3">При добавлении нового значения <em>T</em> размер коллекции увеличивается на единицу, а при добавлении имеющегося значения <em>T</em> размер остаётся прежним</li>
		<li v="4 5 6" hint="4-6">При добавлении нового ключа <em>K</em> размер коллекции увеличивается на единицу</li>
		<li v="4 5 6" hint="4-6">При добавлении имеющегося ключа <em>K</em> размер остаётся прежним, а значение <em>V</em> увеличивается на единицу</li>
		<li v="7 8 9 10 11 12 13 14 15" hint="7-15">При добавлении новой пары ключ-значение <em>K, V</em> размер коллекции увеличивается на единицу, а при добавлении имеющейся пары ключ-значение <em>K, V</em> размер не изменяется</li>
		<li v="1 2 3" hint="1-3">Оператор [] принимает добавленное значение <em>T</em> и возвращает истину</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">Метод, проверяющий наличие ключа принимает добавленный ключ <em>K</em> и возвращает истину</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">Оператор [] принимает добавленный ключ <em>K</em> и возвращает его значение <em>V</em></li>
		<li v="1 2 3" hint="1-3">При удалении существующего значения <em>T</em> размер коллекции уменьшается на единицу, а при удалении отсутствующего значения <em>T</em> размер не изменяется</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">При удалении существующего ключа <em>K</em> размер коллекции уменьшается на единицу, а при удалении отсутствующего ключа <em>K</em> размер не изменяется)</li>
		<li v="1 2 3" hint="1-3">Оператор [] принимает удалённое значение <em>T</em> и возвращает ложь</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">Метод, проверяющий наличие ключа принимает удалённый ключ <em>K</em> и возвращает ложь</li>
		<li>Непустая коллекция после удаления всех объектов равна коллекции, созданной при помощи конструктора по умолчанию)</li>
		<li v="1 2 3" hint="1-3">При пересечении любой коллекции с пустой, оператор &amp;&amp; возвращает пустую коллекцию (any &amp;&amp; empty == empty)</li>
		<li v="1 2 3" hint="1-3">При пересечении одинаковых коллекций, оператор &amp;&amp; возвращает новую коллекцию, равную любой из них (any && any == any)</li>
		<li v="1 2 3" hint="1-3">Копия непустой коллекции равна оригиналу, после вставки или удаления <em>T</em> равенство нарушается</li>
		<li v="4 5 6 7 8 9 10 11 12 13 14 15" hint="4-15">Копия непустой коллекции равна оригиналу, после изменения одного из значений <em>V</em> равенство нарушается</li>
		<li>Непустая коллекция, сохранённая в файл, равна новой коллекции, загруженной из того же файла</li>
	</ol>
</ul>
<ul class="optional task" value="20">
	<h4>Собственная реализация</h4>
	<li class="spoiler">Класс не использует готовые решения</li>
	<ul>
		<li>в самой коллекции не используются шаблонные классы сторонних библиотек (stl, Qt, boost и т.п.)</li>
		<li>это требование <strong>не является обязательным</strong> для получения оценки</li>
	</ul>
</ul>
<ul class="optional task" value="20">
	<h4>Эффективность кода</h4>
	<li class="spoiler">Временн<strong>а</strong>я сложность не превышает ожидаемую</li>
	<ul>
		<li v="1 2 3 5 6 7 8 9" hint="1-9">время вставки, удаления и поиска значения не зависит от количества значений в коллекции</li>
		<li v="10 11 12" hint="10-12">время вставки, удаления и поиска значения линейно зависит от глубины дерева</li>
		<li v="13 14 15" hint="13-15">время вставки, удаления и поиска значения линейно зависит от длины ключа <em>K</em></li>
		<li>подробнее о <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0">временн<strong>о</strong>й сложности</a></li>
	</ul>
	<li class="spoiler">Методы, не изменяющие поля класса, объявлены как константные (const)</li>
	<ul>
		<li>метод, возвращающий количество хранящихся значений</li>
		<li>метод, сохраняющий содержимое коллекции в произвольный файл</li>
		<div>и прочие методы, не добавляющие и не удаляющие хранящиеся в коллекции данные</div>
	</ul>
	<li class="spoiler">Ненужное копирование избегается передачей значений по ссылке (&amp;)</li>
	<ul>
		<li><strong>исключение:</strong> базовые типы данных (int, double, char, bool и т.п.)</li>
	</ul>
</ul>
<ul class="optional task" value="10">
	<h4>Оформление кода</h4>
	<li class="spoiler">Код программы выдержан в одном стиле</li>
	<ul>
		<li>на протяжении всего кода программы, выбранные пользователем имена переменных придерживаются одного и того же стиля написания (например, Upper<a href="https://ru.wikipedia.org/wiki/CamelCase">CamelCase</a> для классов, lowerCamelCase для полей и методов, SCREAMING_<a href="https://ru.wikipedia.org/wiki/Snake_case">SNAKE_CASE</a> для констант)</li>
	</ul>
	<li class="spoiler">Имена переменных осмысленны</li>
	<ul>
		<li>имена классов, методов и полей отражают их конкретную роль в программе</li>
		<li><strong>исключение:</strong> переменные в циклах, временные переменные</li>
	</ul>
	<li class="spoiler">Длины строк не превышают 80 символов</li>
	<ul>
		<li><strong>исключение:</strong> строки с комментариями</li>
	</ul>
</ul>
<h3>II. Заключительный этап</h3>
<ul class="required task" value="30">
	<h4>Графический интерфейс</h4>
	<li class="spoiler">Присутствуют все элементы интерфейса для работы с коллекцией</li>
	<ul>
		<li>есть возможность добавлять и удалять элементы коллекции, а также сохранять коллекцию в указанный пользователем файл и загружать коллекцию из указанного пользователем файла</li>
		<li>присутствуют элементы интерфейса, необходимые для проверки выполнения задания (в зависимости от варианта)</li>
	</ul>
	<li class="spoiler">Есть элемент интерфейса, отображающий всё содержимое коллекции</li>
	<ul>
		<li>для вывода коллекции используется <a href="https://doc.qt.io/qt-5/qlistwidget.html">QListWidget</a>, <a href="https://doc.qt.io/qt-5/qtablewidget.html">QTableWidget</a> или <a href="https://doc.qt.io/qt-5/qtreewidget.html">QTreeWidget</a></li>
	</ul>
</ul>
<ul class="required task" value="40">
	<h4>Тестирование</h4>
	<li>Тесты из предыдущей части продолжают выполняться</li>
	<li>Программа работает с конкретными типами данных, указанными в варианте</li>
	<li>Программа решает поставленную задачу, не допуская при этом ошибок</li>
</ul>
<ul class="optional task" value="5">
	<h4>Оформление кода</h4>
	<li class="spoiler">Код программы выдержан в одном стиле</li>
	<ul>
		<li>на протяжении нового кода программы, выбранные пользователем имена переменных всё ещё придерживаются одного и того же стиля написания</li>
	</ul>
	<li class="spoiler">Имена переменных осмысленны</li>
	<ul>
		<li>имена классов, методов и полей отражают их конкретную роль в программе</li>
		<li><strong>исключение:</strong> переменные в циклах, временные переменные</li>
	</ul>
	<li class="spoiler">Длины строк не превышают 80 символов</li>
	<ul>
		<li><strong>исключение:</strong> строки с комментариями</li>
	</ul>
</ul>
<ul class="optional task" value="5">
	<h4>Оформление интерфейса</h4>
	<li class="spoiler">Каждый из элементов интерфейса выполняет свою определённую задачу</li>
	<ul>
		<li>поля, кнопки и прочие интерактивные элементы подписаны в соответствии со своей ролью в приложении</li>
	</ul>
	<li class="spoiler">Элементы интерфейса подстраиваются к размерам окна</li>
	<ul>
		<li>для каждого окна приложения задана своя компоновка (<a href="http://doc.qt.io/qt-5/layout.html">layout</a>)</a></li>
		<li>в компоновке окна находятся все элементы интерфейса (т.е. виджеты) и другие объекты компоновки</li>
	</ul>
</ul>
<ul class="optional task" value="10">
	<h4>Эффективность кода</h4>
	<li class="spoiler">Уместно используются auto и typedef</li>
	<ul>
		<li><strong>auto</strong> применяется для вывода типа (например, при совмещении объявления с инициализацией)</li>
		<li><strong>typedef</strong> используется для присвоения нового имени для готовой конструкции (например, для шаблонной коллекции)</li>
	</ul>
	<li class="spoiler">Методы, не изменяющие поля класса, объявлены как константные (const)</li>
	<ul>
		<li>метод, сохраняющий содержимое коллекции в произвольный файл</li>
		<div>и прочие методы, не добавляющие и не удаляющие хранящиеся в коллекции данные</div>
	</ul>
</ul>
<ul class="optional task" value="10">
	<h4>Эффективность интерфейса</h4>
	<li class="spoiler">Элементы интерфейса адаптируются к ситуации</li>
	<ul>
		<li>элемент интерфейса, выводящий содержимое коллекции, автоматически обновляется при её изменении</li>
		<li>пользователь получает обратную связь (напр. всплывающая подсказка, диалоговое окно) при совершении ошибки</li>
		<li>интерактивные элементы интерфейса выключаются или скрываются в моменты, когда нет возможности или смысла с ними взаимодействовать</li>
		<li><strong>примеры:</strong> кнопка удаления записей (в случае пустой коллекции), кнопка добавления записей (в случае пустых или неверно заполненных полей ввода) и т.п.</li>
	</ul>
</ul>
<script>
const showVar = index => document.querySelectorAll('[v]').forEach(x => {with (x.classList)(x.getAttribute('v').split(' ').includes(`${index+1}`) ? remove('hidden') : add('hidden'))})
const changeVar = event => showVar(event.target.selectedIndex)
function onLoad() {
document.querySelectorAll('a').forEach(x => x.setAttribute('target', '_blank'))
document.getElementById('problems').setAttribute('style', 'list-style: none;')
document.querySelectorAll('.nojs').forEach(x => x.classList.toggle('hidden'))
document.querySelectorAll('[hint]').forEach(x => x.removeAttribute('hint'))
document.querySelectorAll('.spoiler').forEach(x => (x.onclick = (() => x.classList.toggle('closed')))())
with (document.getElementById('selector')) [...Array(15).keys()].forEach(x => {let o = document.createElement('option'); o.innerText = x+1; o.value="#test"; appendChild(o)})
showVar(0)
}
</script>
</body>
</html>